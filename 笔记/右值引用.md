# 右值引用
**右值引用**是C++11后引入的语法特性,C++98就有引用的语法,叫做**左值引用**.无论是左值引用还是右值引用,本质都是给对象取别名.

## 左值和右值
在理解**右值引用**前,先引入左值和右值的概念,左值和右值都是一个表示数据的表达式.

**左值**(locator value,lvalue):一般有持久状态,存储在内存中,可以对其取地址即在前放置`&`符号.左值可以出现在赋值符号`=`的左右.经过`const`修饰后的左值虽然不可以进行赋值,但是**可以取它的地址**.

```cpp
// 左值:可以地址
// 以下的pb、c、*p、s[0]就是常见的值
int* p = newint(0);
int b = 1;
const int c =b;
*p = 10;
string ("111111");
s[0] = 'x';
```

**右值**(read value, rvalue):字面值常量(1, 'c'等),表达式求值过程中创建的临时对象等,右值只可以出现在赋值符号的右边,**不可以取地址**.

```cpp
// 右值:不能地址
double x = 11, y = 2.2;
// 以下的10、x + y、fmin(x, y)、string("11111")都常见的右值
10;
x + y;
fmin(x, y);
strin("11111");

// error:表式必须是左值函数指示符
// cout << 10 << endl;
// cout << &(+y) << endl;
// cout << (fmin(x, y))<< endl;
// cout << strin("11111") <<endl;
```

<font color=red>总结</font>:左值和右值的核心区别就是**能否取地址**.

## 左值引用和右值引用
`Type& r1 = x; Type&& rr1 = y;`
第一个语句是**左值引用**,左值引用是给左值取别名;第二个语句是**右值引用**,右值引用是给右值取别名.

对于上述的`pb、c、*p、s、s[0]`,都可以进行左值引用.
```cpp
// 左值引⽤给值取别名
int& r1 = b;
int*& r2 = p;
int& r3 = *p;
string& r4 =s;
char& r5 = [0];
```

对于上述的`10、x + y、fmin(x, y)、string("11111")`,都可以进行右值引用

```cpp
 // 右值引用给右值取别名
 int&& rr1 = 10;
 double&& rr2 = x + y;
 double&& rr3 = fmin(x, y);
 string&& rr4 = string("11111");
```

左值引用不能直接引用右值,但是`const`左值引用可以引用右值;右值引用不能直接引用左值,但是右值引用可以引用move(左值).
(move是库里面的⼀个函数模板，本质内部是进行强制类型转换).

```cpp
// 左值引用不直接引用右值,但是const左引用可以引用值
const int&rx1 = 10;
const double&rx2 = x + y;
const double&rx3 = fmin(x,y);
const string&rx4 = strin("11111");

// 右值引用不直接引用左值,是右值引用可引用move(左值)
int&& rrx1 =move(b);
int*&& rrx2 =move(p);
int&& rrx3 =move(*p);
string&& rrx4= move(s);
string&& rrx5= (string&&)s;
```
需要<font color = red>注意</font>的是变量表达式都是**左值属性**，也就意味着一个右值被右值引用绑定后，右值引用变量变量表达式的属性是左值.

```cpp
// b、r1、rr1都是变量表达式都是左值,都可取地址
cout << &b <<endl;
cout << &r1<< endl;
cout << &rr1<< endl;
```

右值引用不能再被右值引用绑定,除非move一下.
```cpp
int& r6 = r1;
// int&& rrx6= rr1; error
int&& rrx6 =move(rr1);
```

