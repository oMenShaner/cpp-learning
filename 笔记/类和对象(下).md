# 一. 再谈构造函数
## 1. 构造函数体赋值
> 在创建对象时, 编译器通过调用构造函数, 给对象中的各个成员一个合适的初始值.

```cpp
class Date
{
public:
  Date(int year, int month, int day)
  {
    _year = year;
    _month = month;
    _day = day;
  }

private:
  int _year;
  int _month;
  int _day;
};

int main()
{
  Date d1(2023, 11, 2);   //定义加初始化

  return 0;
}
```

类相当于声明, `main` 函数中的 `Date d1(2023, 11, 2);`相当于定义加初始化.

虽然上述构造函数调用一次后, 对象中已经有了个初始值, 但是不能将其称为对对象中成员变量进行初始化.

**构造函数体中的语句只能将其称为赋初值**, 而不能称为初始化.因为**初始化只能初始化一次, 而构造函数体内可以多次赋值**.

如果 `Date` 中有一个引用成员变量或者是 `const` 成员变量, 也可以用构造函数体初始化吗?

显然是不可以的, 类中成员变量声明和定义分离, 但是引用和 `const` 常变量都要求在声明的时候同时需要初始化.

![1699273742573](image/类和对象(下)/1699273742573.png)
编译器提示引用和 `const` 常变量没有初始化. 因为构造函数体并不是真正的初始化定义的地方, 只是一个赋值的地方. 

**真正类成员定义的地方是在构造函数初始化列表的地方.**

## 2. 初始化列表
> 初始化列表: 以一个**冒号开始**, 接着是一个以**逗号分隔的数据成员列表**, 每个"**成员变量**"后面跟一个**放在括号中的初始值或表达式**.

```cpp
class Date
{
public:
  Date(int year, int month, int day)
  : _year(year)
  , _month(month)
  , _day(day)
  , x(_year)
  , y(month)
  {}

private:
  int _year;
  int _month;
  int _day;

  int& x;
  const int y;
};

int main()
{
  Date d1(2023, 11, 2);   //定义加初始化

  return 0;
}
```
初始化列表是每个成员定义的地方, 这样引用和 `const` 成员变量在初始化列表位置进行初始化就不会出现错误了.

***
还有几点关于初始化列表需要注意:

> 1. 每个成员变量在初始化列表中**只能出现一次**(初始化只能初始化一次)

编译器会直接报错
![1699274262694](image/类和对象(下)/1699274262694.png)

***
> 2. 类中包含以下成员, 必须在初始化列表进行初始化:
> - 引用成员变量
> - `const` 成员变量
> - 自定义类型成员(且该类没有默认构造函数时)


```cpp
class A       // A类 没有默认构造函数
{
public:
  A(int a)  
  : _a(a)
  {}
private:
  int _a;
};

class B
{
public:
  B(int x, int a, int ref, int n)
  : _x(x)       // 普通成员变量初始化
  , _aobj(a)    // 自定义成员初始化
  , _ref(ref)   // 引用成员初始化
  , _n(n)       // const 成员初始化
  {}
private:
  int _x;       // 普通成员变量
  A _aobj;      // 没有默认构造函数
  int& _ref;    // 引用
  const int _n; // const
};
```


***
> 3. 没有在初始化列表中的成员也会定义, 但是**内置类型是随机值**, **自定义类型会调用其默认构造函数**.
> 如果自定义类型没有默认构造函数, 则会编译报错.

**内置成员变量没有在初始化列表定义初始化, 也不在构造函数函数体内部赋值**:
```cpp
  B(int x, int a, int ref, int n)
  : _aobj(a)    // 自定义成员初始化
  , _ref(ref)   // 引用成员初始化
  , _n(n)       // const 成员初始化
  {}
```

![1699275934014](image/类和对象(下)/1699275934014.png)
如果成员没有在初始化列表进行定义, 也没有在构造函数体内部进行赋值, 最终成员是随机值.

注意, 这里的引用也是随机值, 是因为 `_ref` 引用了一个栈帧开辟的临时变量, 虽然不会因为未初始化报错, 但是这样的引用肯定也是不正确的.

**自定义类型没有默认构造函数, 也没有在初始化列表中进行定义, 会直接编译报错:**
![1699276423967](image/类和对象(下)/1699276423967.png)

如果将 `A` 类的构造函数改成默认构造函数, 就不会出现编译错误.

*** 
> 4. 初始化列表优先于缺省值, 只有初始化列表没有显示初始化的时候, 才会使用成员变量的缺省值.

```cpp
class Date
{
public:
  Date(int year, int month, int day)
  : _year(2)        // 初始化列表也定义了值
  , _month(month)
  , _day(day)
  {}

private:
  int _year = 1;    // 缺省值
  int _month;
  int _day;
};
```
虽然输入了 4, 并没有用到 4. 同时也没有用到缺省值 1, 最终还是初始化列表中的初始化值 2.
![1699277245394](image/类和对象(下)/1699277245394.png)

***
> 5. 尽量使用初始化列表初始化, 因为不管是否使用初始化列表, 对于自定义类型成员变量, 一定会先使用初始化列表初始化.

