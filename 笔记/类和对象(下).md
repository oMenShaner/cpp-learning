# 一. 再谈构造函数

## 1. 构造函数体赋值

> 在创建对象时, 编译器通过调用构造函数, 给对象中的各个成员一个合适的初始值.

```cpp
class Date
{
public:
  Date(int year, int month, int day)
  {
    _year = year;
    _month = month;
    _day = day;
  }

private:
  int _year;
  int _month;
  int _day;
};

int main()
{
  Date d1(2023, 11, 2);   //定义加初始化

  return 0;
}
```

类相当于声明, `main` 函数中的 `Date d1(2023, 11, 2);`相当于定义加初始化.

虽然上述构造函数调用一次后, 对象中已经有了个初始值, 但是不能将其称为对对象中成员变量进行初始化.

**构造函数体中的语句只能将其称为赋初值**, 而不能称为初始化.因为**初始化只能初始化一次, 而构造函数体内可以多次赋值**.

如果 `Date` 中有一个引用成员变量或者是 `const` 成员变量, 也可以用构造函数体初始化吗?

显然是不可以的, 类中成员变量声明和定义分离, 但是引用和 `const` 常变量都要求在声明的时候同时需要初始化.

![1699273742573](<image/类和对象(下)/1699273742573.png>)
编译器提示引用和 `const` 常变量没有初始化. 因为构造函数体并不是真正的初始化定义的地方, 只是一个赋值的地方.

**真正类成员定义的地方是在构造函数初始化列表的地方.**

## 2. 初始化列表

> 初始化列表: 以一个**冒号开始**, 接着是一个以**逗号分隔的数据成员列表**, 每个"**成员变量**"后面跟一个**放在括号中的初始值或表达式**.

```cpp
class Date
{
public:
  Date(int year, int month, int day)
  : _year(year)
  , _month(month)
  , _day(day)
  , x(_year)
  , y(month)
  {}

private:
  int _year;
  int _month;
  int _day;

  int& x;
  const int y;
};

int main()
{
  Date d1(2023, 11, 2);   //定义加初始化

  return 0;
}
```

初始化列表是每个成员定义的地方, 这样引用和 `const` 成员变量在初始化列表位置进行初始化就不会出现错误了.

---

还有几点关于初始化列表需要注意:

> 1. 每个成员变量在初始化列表中**只能出现一次**(初始化只能初始化一次)

编译器会直接报错
![1699274262694](<image/类和对象(下)/1699274262694.png>)

---

> 2. 类中包含以下成员, 必须在初始化列表进行初始化:
>
> - 引用成员变量
> - `const` 成员变量
> - 自定义类型成员(且该类没有默认构造函数时)

```cpp
class A       // A类 没有默认构造函数
{
public:
  A(int a)
  : _a(a)
  {}
private:
  int _a;
};

class B
{
public:
  B(int x, int a, int ref, int n)
  : _x(x)       // 普通成员变量初始化
  , _aobj(a)    // 自定义成员初始化
  , _ref(ref)   // 引用成员初始化
  , _n(n)       // const 成员初始化
  {}
private:
  int _x;       // 普通成员变量
  A _aobj;      // 没有默认构造函数
  int& _ref;    // 引用
  const int _n; // const
};
```

---

> 3. 没有在初始化列表中的成员也会定义, 但是**内置类型是随机值**, **自定义类型会调用其默认构造函数**.
>    如果自定义类型没有默认构造函数, 则会编译报错.

**内置成员变量没有在初始化列表定义初始化, 也不在构造函数函数体内部赋值**:

```cpp
  B(int x, int a, int ref, int n)
  : _aobj(a)    // 自定义成员初始化
  , _ref(ref)   // 引用成员初始化
  , _n(n)       // const 成员初始化
  {}
```

![1699275934014](<image/类和对象(下)/1699275934014.png>)
如果成员没有在初始化列表进行定义, 也没有在构造函数体内部进行赋值, 最终成员是随机值.

注意, 这里的引用也是随机值, 是因为 `_ref` 引用了一个栈帧开辟的临时变量, 虽然不会因为未初始化报错, 但是这样的引用肯定也是不正确的.

**自定义类型没有默认构造函数, 也没有在初始化列表中进行定义, 会直接编译报错:**
![1699276423967](<image/类和对象(下)/1699276423967.png>)

如果将 `A` 类的构造函数改成默认构造函数, 就不会出现编译错误.

---

> 4. 初始化列表优先于缺省值, 只有初始化列表没有显示初始化的时候, 才会使用成员变量的缺省值.

```cpp
class Date
{
public:
  Date(int year, int month, int day)
  : _year(2)        // 初始化列表也定义了值
  , _month(month)
  , _day(day)
  {}

private:
  int _year = 1;    // 缺省值
  int _month;
  int _day;
};
```

虽然输入了 4, 并没有用到 4. 同时也没有用到缺省值 1, 最终还是初始化列表中的初始化值 2.
![1699277245394](<image/类和对象(下)/1699277245394.png>)

---

> 5. 尽量使用初始化列表初始化, 因为不管是否使用初始化列表, 对于自定义类型成员变量, 一定会先使用初始化列表初始化.

```cpp
class Time
{
public:
  Time(int t = 4)
  {
    cout << "Time(int t = 4)" << endl;
    _t = t;
  }
private:
  int _t;
};

class Date
{
public:
  Date()
  {}
private:
  int _day;
  Time _t;
};
```

如果类中有自定义成员, 且该自定义类有默认构造函数, 即使类中没有初始化列表, 编译器也会自动调用该自定义成员的默认构造函数.

初始化列表是一个成员定义的地方, 即使没有显示写, 程序也会走隐含的初始化列表, 最终结果就是: **内置类型是随机值, 自定义类型调用它的默认构造函数**.
![Alt text](<image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/image-1.png>)

---

> 6. **成员变量**在类中**声明次序**就是其在初始化列表中的**初始化顺序**, 与其在初始化列表中的先后次序无关

问下面的代码最后打印什么?

```cpp
class A
{
public:
  A(int a)
    :_a1(a)
    ,_a2(_a1)
  {}

  void Print()
  {
    cout << _a1 << ' ' << _a2 << endl;
  }

private:
  int _a2;
  int _a1;
};

int main()
{
  A aa(1);
  aa.Print();

  return 0;
}
```

答案是 `1 随机值`

虽然初始化列表中 `_a1` 在 `_a2` 的前面, 但是实际初始化的顺序是按照类中成员定义的顺序的.

在类中 `_a2` 先于 `_a1`, 所以先初始化 `_a2`, 但是此时 `_a1` 尚未初始化, 是随机值, 即 `_a2` 是随机值. 接着用 `1` 初始化 `_a1`.

![Alt text](<image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/image.png>)

---

<font color=red>总结</font>
**初始化列表解决的问题**

- 必须在定义初始化的成员(引用成员变量, `const`成员变量, 没有默认构造函数的自定义成员)
- 有些自定义成员想要自己显示初始化, 自己来控制

**80%-100%用初始化列表进行定义**

- 有些事初始化列表并不能做, 比如 `_a((int*)malloc(sizeof(int) * capacity))`, 虽然这样给 `_a` 初始化了, 但是却不能在初始化列表进行检查 `malloc` 是否成功, 检查只能在构造函数函数体进行.

## 3. explitcit 关键字

下述的类, 会有一种特殊的构造

```cpp
class A
{
public:
  A(int a)
  :_a(a)
  {
    cout << "A(int a)" << endl;
  }

  A(const A& aa)
  {
    _a = aa._a;
    cout << "A(const A aa)" << endl;
  }
private:
  int _a;
};

int main()
{
  A aa1 = 1;  //会发生隐式类型转换

  return 0;
}

```

表达式 `A aa1 = 1;` 看起来会出错, 将一个 `int` 类型的对象赋值给了一个 `A` 类型的对象.

但是却自动发生了隐式类型转换, 首先会用 `1` 构造了一个临时对象, 再用这个临时对象拷贝构造 `aa1`
![Alt text](<image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/image-2.png>)

![Alt text](<image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/image-3.png>)

需要注意的是, 这种隐式转换只适用于**内置类型或者单参数(传一个参数的半缺省)构造函数支持**

如果类的构造函数需要两个参数, 或者隐式转换不了对应的参数类型, 会直接编译报错.

![Alt text](<image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/image-4.png>)

---

如果不想隐式转换, 可以在构造函数前加 `explicit` 关键字.

> 构造函数不仅可以构造和初始化对象, **对于单个参数或者除第一个参数无默认值其余均有默认值的构造函数, 还具有隐式类型转换的作用**
> 加上 `explicit` 可以防止隐式类型转换

![Alt text](<image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/image-5.png>)

---

如果构造函数有一个参数, 且使用了 `explicit` 关键字, 强制转换依旧是可以的

```cpp
A aa1 = A(1);
```

这样就相当于先使用 `1` 调用构造函数构造了一个匿名对象, 随后用这个匿名对象拷贝构造 `aa1`.

---

<font color=red>补充</font>

> C++98 不支持多参数隐式转换
> C++11 支持多参数隐式转换

例如:

```cpp
Date d1 = {2023, 1, 3}; //列表初始化
//不是下面这种写法
//Date d1 = (2023, 1, 3); //相当于 Date d1 = 3;
```

先用 `2023, 1, 3` 作为构造函数参数创建了一个临时变量, 随后用临时变量拷贝构造 `d1`.

> 如果想要良好的代码可读性, 推荐使用 `explicit` 关键字
