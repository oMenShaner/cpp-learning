# 1. 面向对象和面向对象初步认识
> c语言是**面向过程**的, 关注的是过程, 分析出求解问题的步骤, 通过函数调用逐步解决问题.

> c++是**基于面向对象**的, 关注的是对象, 将一件事情拆分成不同的对象, 靠对象之间的交互完成. 

![1698323345597](image/类和对象(上)/1698323345597.png)
这是计算机体系结构中八个伟大思想中的一个: **使用抽象简化设计--降低低层细节以提供给高层一个更简单的模型**

# 2. 类的引入
> **C语言结构体中只能定义变量, 在c++中, 结构体内不仅可以定义变量, 也可以定义函数**


1. 在c++中 `struct` 升级成了类, 不用 `typedef` 重命名.
2. 可以直接用 `struct` 后面的类名创建对象.

例如:
```cpp
typedef int STDataType;
struct Stack
{
    void Init(size_t capacity)
    {
        _array = (STDataType*)malloc(sizeof(STDataType) * capacity);
        if (nullptr == _array)
        {
            perror("malloc fail");
            return;
        }

        _capacity = capacity;
        _top = 0;
    }

    void Push(const STDataType& data)
    {
        _array[_top] = data;
        _top++;
    }

    void Destroy()
    {
        if (_array)
        {
            free(_array);
            _array = nullptr;
            _capacity = _top = 0;
        }
    }
    STDataType* _array;
    int _capacity;
    int _top;
};

int main()
{
    Stack s;
    s.Init(10);
    s.Push(1);
    s.Push(2);
    s.Push(3);
    s.Push(4);
    s.Push(5);

    s.Destroy();

    return 0;
} 
```
> 1. 类名就是类型, 创建对象的时候不需要加 `struct`, 直接 `Stack` 即可
> 2. 类里面可以定义成员函数, 调用函数可直接用 `结构体变量` + `.` + `成员函数`的格式

很明显, c++中的类更为精简.
![1698326176829](image/类和对象(上)/1698326176829.png)

**在c++中更喜欢用`class`来代替`struct`进行类的定义**

# 3. 类的访问限定符
> c++实现封装的方式: **用类将对象的属性和方法结合在一块, 让对象更加完善, 通过访问权限选择性的将接口提供给外部的用户使用**

通过权限访问符可以一定程度上保护类的成员. C++ 访问限定符一共有三种: 
![1698327338832](image/类和对象(上)/1698327338832.png)

> 1. `public` 修饰的成员在类外可以直接被访问.
> 2. `protected` 和 `private` 修饰的成员在类外不能直接被访问.(此处`protected` 和 `private` 是相似的)
> 3. 访问权限**作用在从该访问限定符出现的位置一直到下一个访问限定符出现为止**.
> 4. 如果后面没有访问限定符, 作用域就到 `}` 结束
> 5. `class` 的默认访问权限默认是 `private`; `struct` 的默认访问权限默认是 `public` (要兼容c语言)

<font color='red'>注意: 访问限定符只在编译时有用, 当数据映射到内存后, 没有任何访问限定符上的区别</font>

通常来说, 将类的成员变量的访问权限设置成 `private`.
1. `s.Empty()`(成员变量设置成私有) 和 `s.top == 0`(成员变量设置成公有). 两者相比肯定是前一种更好. 前一种更为规范, 既然同一抽象层次的都是使用这一种格式, 例如 `s.Init(10)` `s.Push(1)`, 显然前一种更好.
2. `s.Empty()`见名知意, 知道这个函数返回的是栈对象是否空的结果. 而 `s.top == 0` 需要更加进一步思考, 代码可读性明显降低了.

***
**问题: C++中 `struct` 和 `class` 的区别是什么?**
解答:
- C++ 需要兼容 C语言, 所以 C++ 中可以使用 `struct` 定义结构体.
- 另外 C++ 也可以用 `struct` 定义类. 和 `class` 定义类是一样的. 结构体名同时也是类名
- 不同的是 `struct` 定义的类默认访问权限是 `public`; `class` 定义的类默认访问权限是 `private`

# 4. 类的定义
```cpp
class ClassName
{
    // 类体: 由成员函数和成员变量组成

};  // 一定要注意后面的分号
```
> 1. `class` 为定义类的关键字, `ClassName` 为类的名字, `{}` 中为类的主体, `{}` 内为一个域. **注意类定义结束后面分号不能省略**.

> 2. 类体中内容被称为**类的成员**: 类中的**变量**称为**类的属性**或**成员变量**;类中的**函数**称为**类的方法**或者**成员函数**.

## 类的两种定义方式
1. 声明和定义全部放在类体中, 需注意: 成员函数如果**在类中定义**, 编译器可能会将其当成**内联函数**处理.

![1698329777851](image/类和对象(上)/1698329777851.png)

2. 类声明放在头文件 `.h` 文件中, 成员函数定义放在 `.cpp` 文件中, 注意: **定义成员函数名前需要加`类名::`**(每一个类是一个域, 需要用到`::`来指明函数是在哪个域中间的)

![1698329695730](image/类和对象(上)/1698329695730.png)

更推荐使用第二种定义方法, 在类中定义的成员函数默认是 `inline` 的, 也可以直接将短小的成员函数直接放在类定义中.

正确用法: 长函数和声明分离, 短小函数声明定义不分离.

***
## 成员变量名规则的建议
如果我们定义了一个 `Date` 类, 需要写一个初始化年份的成员函数, 那么下面的代码中的两个 `year` 分别指什么呢?

这里两个 `year` 都是函数创建的局部变量, 会自我赋值, 与初衷相悖.

![1698330271695](image/类和对象(上)/1698330271695.png)
为了进行区别, 一般内部的成员变量命名都会在前面添加一个 `_`, 例如 `_year`

```cpp
class Date
{
public:
    void Init(int year, int month, int day)
    {
        _year = year;
        _month = month;
        _day = day;
    }
    void Print()
    {
        cout << _year << '-' << _month << '-' << _day << endl;
    }
private:
    int _year;
    int _month;
    int _day;
};

int main()
{
    Date d;
    d.Init(2020, 1, 1);
    d.Print();

    return 0;
}

```
程序运行结果如下: 
![1698330464407](image/类和对象(上)/1698330464407.png)

# 5. 类的作用域
> **类定义了一个新的作用域**, 类的所有成员都在类的作用域中. 在类体外定义成员时, 需要使用 `::` 作用域操作符指明成员使用哪个类域.

```cpp
typedef int STDataType;

class Stack
{
public:
    void Init(int capacity); 
private:
    STDataType* _array;
    int _capacity;
    int _top;
};

// 这里需要指定 Init 是属于 Stack 这个类域的
void Stack::Init(int capacity)
{
  _array = (STDataType*)malloc(sizeof(STDataType) * capacity);
  if (nullptr == _array)
  {
    perror("malloc fail");
    return;
  }

  _capacity = capacity;
  _top = 0;
}
```

# 6. 类的实例化
> 用类类型创造对象的过程, 称为类的实例化.

> 1. **类是对对象进行描述的**, 是一个**模型**一样的东西, 定义出一个类**并没有分配实际的内存空间**来存储它.

就拿 `int` 来说, 类和 `int` 在某些方面是一样的, 指明接下来创建的对象是什么类型的. 我直接对 `int` 进行赋值显然是不可能的, 类也一样.

变量的声明和定义的区别就是是否开了内存空间, `int` 告诉编译器如果我需要定义一个 `int` 类型的变量, 需要让操作系统给我分配一块 `4字节` 大小的空间. 只有当真正我**定义**了一个变量(`int a;`), 这个时候才会真正有一个 `int` 类型的对象存在.

依次类推, 类的声明也让编译器告诉操作系统, 如果我需要创建一个类类型的对象, 操作系统要给我分配这么大的空间, 相当于一个告示, 一个提醒. 只有当用类真正创建了一个具体的对象的时候, 内存中才会有一个具体的类类型的对象存在.

> 2. 一个类可以实例化出多个对象, **实例化出的对象 占用实际的物理空间, 存储类成员变量**
```cpp
int main()
{
    Date._year = 1000;      // 编译失败, 语法错误

    return 0;
}
```
`Date` 类是没有具体空间的, 只有 `Date` 类实例化出的对象才有具体的年月日.

> 3. 打个比方. **类实例化出对象就像现实中使用建筑设计图建造出房子, 类就像是设计图**, 只是蓝图, 但是并没有实际的建筑存在, 同时类也只是一个设计, 实例化出的对象才能实际存储数据, 占用物理空间.

![1698476417291](image/类和对象(上)/1698476417291.png)

需要注意的是, 成员函数(类的方法)不存在在对象里, 它实际就是正常的函数, 只是限定在类这个域中, 调用成员函数和调用正常函数的操作是一样的. c++的命名规则会将成员函数和正常函数做出区分.

就比如一个小区, 每家每户的图纸都是一样的, 具体每一户内部的物品是不一样的.**对应于类创建的多个实例化对象的成员变量可以不一样的.**

每个小区都有公共的停车场, 花园等等, 但这些不需要特指是哪一家的, 只需要知道是这个小区的就行了. **对应于类的成员函数不需要用类类型生成的对象存储, 只要该对象是这个类类型的, 就可以调用该类的成员函数.**

# 7. 类对象模型
## 计算类对象的大小 类的实际存储方式
为了验证 C++ 中类的对象只存放了成员变量, 写下了如下代码:

```cpp
typedef int STDataType;
class Stack
{
private:
    STDataType* _array;
    int _capacity;
    int _top;
public:
    void Init(int capacity);
    void Push(STDataType x);
};

class A
{
    
};

class B
{
private:
    char _a;
public:
    void printB()
    {
        cout << _a << endl;
    }
};

class C
{
private:
    char _a;
};

int main()
{
    Stack st;   //类实例化一个对象
    cout << sizeof(st) << endl;
    cout << sizeof(Stack) << endl;
    cout << sizeof(A) << endl;
    cout << sizeof(B) << endl;
    cout << sizeof(C) << endl;

    return 0;
}
```
程序运行如下: 
![1698477417453](image/类和对象(上)/1698477417453.png)

![1698478460077](image/类和对象(上)/1698478460077.png)
> **一个类的大小, 实际上就是该类中"成员变量"之和, 当然要注意内存对齐**
> **注意空类的大小, 空类比较特殊, 编译器给了空类一个字节来唯一表示这个类的对象**

***

由此可知: 类的对象存储方式是这样的
将成员变量存放到类实例化的对象内, 类的成员函数则放置在一个类成员函数表, 在公共代码区.

![1698478314740](image/类和对象(上)/1698478314740.png)

[结构体对齐规则详见](https://blog.csdn.net/Kuzuba/article/details/131796595?spm=1001.2014.3001.5502)

# 8. this指针
## this指针的引入
> 先定义一个日期类 `Date`
```cpp
class Date
{
public:
    void Init(int year, int month, int day)
    {
        _year = year;
        _month = month;
        _day = day;
    }
    void Print(Date* const this)
    {
        cout << this->_year << '-' << this->_month << '-' << this->_day << endl;
    }
private:
    int _year;
    int _month;
    int _day;
};

int main()
{
    Date d1, d2;
    d1.Init(2000, 1, 1);
    d2.Init(2010, 10, 10);
    d1.Print();
    d2.Print();

    return 0;
}
```
程序正常运行: 
![1698481018007](image/类和对象(上)/1698481018007.png)

但是还是有一个问题:
`Date` 类中有 `Init` 和 `Print` 两个成员函数, 函数体中并没有关于对象的区分, 那么当 `d1` 调用成员函数 `Init` 时, 该函数是如何知道应该设置 `d1` 对象, 而不是设置 `d2` 对象呢?

> C++ 通过引入 `this` 指针解决该问题

> C++ 编译器给每个"非静态的成员函数"增加了一个隐藏的指针函数, 让该指针指向当前对象(函数运行时调用该函数的对象), 在函数体中所有"成员变量"的操作, 都是通过该指针去访问. 

> 只不过所有的操作对用户是透明的, 即用户不需要来传递, 编译器自动完成.


![1698481000937](image/类和对象(上)/1698481000937.png)
## this指针的特性
> 1. **`this`指针的类型: `类类型* const`**, 即成员函数中, 不能给 `this` 指针赋值

> 2. 只能在**成员函数**的内部使用

> 3. **`this`指针本质上是成员函数的形参**, 当对象调用成员函数时, 将对象地址作为实参传递给 `this` 形参. 所以**对象中不存储 `this` 指针**

> 4. **`this` 指针是成员函数第一个隐含的指针形参, 一般情况由编译器通过寄存器自动传递, 不需要用户传递**.

***
`this` 指针存放在哪里<font color='red'>?</font>
> `this` 指针是形参, 一般存放在栈空间中.

`this` 指针可以为空吗<font color='red'>?</font>

-  下面程序编译运行结果是?       A. 编译报错     B. 运行崩溃     C. 正常运行
```cpp

class A
{
public:
	void Print()
	{
		cout <<"Print()" << endl;
	}
private:
	int _a;
};
int main()
{
	A* p = nullptr;
	p->Print();
	return 0;
}

```
程序正常运行. 
![1698481520477](image/类和对象(上)/1698481520477.png)
> 成员函数放置在公共代码区内, 调用成员函数不需要对对象进行解引用, 同时成员函数内部也没有访问到成员变量, 不会发生问题.

***
-  下面程序编译运行结果是?       A. 编译报错     B. 运行崩溃     C. 正常运行
```cpp
class A
{
public:
	void Print()
	{
		cout << _a << endl;
	}
private:
	int _a;
};
int main()
{
	A* p = nullptr;
	p->Print();
	return 0;
}
```
程序运行出错:
![1698481806783](image/类和对象(上)/1698481806783.png)
> 程序运行期间发生了空指针解引用, 成员函数访问到对象的成员变量了, 然而 `this` 指针是一个空指针.

> 空指针解引用是运行崩溃.

本章完.