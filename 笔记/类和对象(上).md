# 1. 面向对象和面向对象初步认识
> c语言是**面向过程**的, 关注的是过程, 分析出求解问题的步骤, 通过函数调用逐步解决问题.

> c++是**基于面向对象**的, 关注的是对象, 将一件事情拆分成不同的对象, 靠对象之间的交互完成. 

![1698323345597](image/类和对象(上)/1698323345597.png)
这是计算机体系结构中八个伟大思想中的一个: **使用抽象简化设计--降低低层细节以提供给高层一个更简单的模型**

# 2. 类的引入
> **C语言结构体中只能定义变量, 在c++中, 结构体内不仅可以定义变量, 也可以定义函数**


1. 在c++中 `struct` 升级成了类, 不用 `typedef` 重命名.
2. 可以直接用 `struct` 后面的类名创建对象.

例如:
```cpp
typedef int STDataType;
struct Stack
{
    void Init(size_t capacity)
    {
        _array = (STDataType*)malloc(sizeof(STDataType) * capacity);
        if (nullptr == _array)
        {
            perror("malloc fail");
            return;
        }

        _capacity = capacity;
        _top = 0;
    }

    void Push(const STDataType& data)
    {
        _array[_top] = data;
        _top++;
    }

    void Destroy()
    {
        if (_array)
        {
            free(_array);
            _array = nullptr;
            _capacity = _top = 0;
        }
    }
    STDataType* _array;
    int _capacity;
    int _top;
};

int main()
{
    Stack s;
    s.Init(10);
    s.Push(1);
    s.Push(2);
    s.Push(3);
    s.Push(4);
    s.Push(5);

    s.Destroy();

    return 0;
} 
```
> 1. 类名就是类型, 创建对象的时候不需要加 `struct`, 直接 `Stack` 即可
> 2. 类里面可以定义成员函数, 调用函数可直接用 `结构体变量` + `.` + `成员函数`的格式

很明显, c++中的类更为精简.
![1698326176829](image/类和对象(上)/1698326176829.png)

**在c++中更喜欢用`class`来代替`struct`进行类的定义**

# 3. 类的访问限定符
> c++实现封装的方式: **用类将对象的属性和方法结合在一块, 让对象更加完善, 通过访问权限选择性的将接口提供给外部的用户使用**

通过权限访问符可以一定程度上保护类的成员. C++ 访问限定符一共有三种: 
![1698327338832](image/类和对象(上)/1698327338832.png)

> 1. `public` 修饰的成员在类外可以直接被访问.
> 2. `protected` 和 `private` 修饰的成员在类外不能直接被访问.(此处`protected` 和 `private` 是相似的)
> 3. 访问权限**作用在从该访问限定符出现的位置一直到下一个访问限定符出现为止**.
> 4. 如果后面没有访问限定符, 作用域就到 `}` 结束
> 5. `class` 的默认访问权限默认是 `private`; `struct` 的默认访问权限默认是 `public` (要兼容c语言)

<font color='red'>注意: 访问限定符只在编译时有用, 当数据映射到内存后, 没有任何访问限定符上的区别</font>

通常来说, 将类的成员变量的访问权限设置成 `private`.
1. `s.Empty()`(成员变量设置成私有) 和 `s.top == 0`(成员变量设置成公有). 两者相比肯定是前一种更好. 前一种更为规范, 既然同一抽象层次的都是使用这一种格式, 例如 `s.Init(10)` `s.Push(1)`, 显然前一种更好.
2. `s.Empty()`见名知意, 知道这个函数返回的是栈对象是否空的结果. 而 `s.top == 0` 需要更加进一步思考, 代码可读性明显降低了.

***
**问题: C++中 `struct` 和 `class` 的区别是什么?**
解答:
- C++ 需要兼容 C语言, 所以 C++ 中可以使用 `struct` 定义结构体.
- 另外 C++ 也可以用 `struct` 定义类. 和 `class` 定义类是一样的. 结构体名同时也是类名
- 不同的是 `struct` 定义的类默认访问权限是 `public`; `class` 定义的类默认访问权限是 `private`

# 4. 类的定义
```cpp
class ClassName
{
    // 类体: 由成员函数和成员变量组成

};  // 一定要注意后面的分号
```
> 1. `class` 为定义类的关键字, `ClassName` 为类的名字, `{}` 中为类的主体, `{}` 内为一个域. **注意类定义结束后面分号不能省略**.

> 2. 类体中内容被称为**类的成员**: 类中的**变量**称为**类的属性**或**成员变量**;类中的**函数**称为**类的方法**或者**成员函数**.

## 类的两种定义方式
1. 声明和定义全部放在类体中, 需注意: 成员函数如果**在类中定义**, 编译器可能会将其当成**内联函数**处理.

![1698329777851](image/类和对象(上)/1698329777851.png)

2. 类声明放在头文件 `.h` 文件中, 成员函数定义放在 `.cpp` 文件中, 注意: **定义成员函数名前需要加`类名::`**(每一个类是一个域, 需要用到`::`来指明函数是在哪个域中间的)

![1698329695730](image/类和对象(上)/1698329695730.png)

更推荐使用第二种定义方法, 在类中定义的成员函数默认是 `inline` 的, 也可以直接将短小的成员函数直接放在类定义中.

正确用法: 长函数和声明分离, 短小函数声明定义不分离.

***
## 成员变量名规则的建议
如果我们定义了一个 `Date` 类, 需要写一个初始化年份的成员函数, 那么下面的代码中的两个 `year` 分别指什么呢?

这里两个 `year` 都是函数创建的局部变量, 会自我赋值, 与初衷相悖.

![1698330271695](image/类和对象(上)/1698330271695.png)
为了进行区别, 一般内部的成员变量命名都会在前面添加一个 `_`, 例如 `_year`

```cpp
class Date
{
    public:
        void Init(int year, int month, int day)
        {
            _year = year;
            _month = month;
            _day = day;
        }
        void Print()
        {
            cout << _year << '-' << _month << '-' << _day << endl;
        }
    private:
        int _year;
        int _month;
        int _day;
};

int main()
{
    Date d;
    d.Init(2020, 1, 1);
    d.Print();

    return 0;
}

```
程序运行结果如下: 
![1698330464407](image/类和对象(上)/1698330464407.png)
