# RAII和智能指针的设计思路

> RAII（Resource Acquisition Acquisition Is Initialization，资源获取即初始化）是 C++ 中管理资源（如内存、文件句柄、锁、网络连接等）的核心设计思想，其核心原则是： **将资源的生命周期与对象的生命周期绑定** —— 在对象构造时获取资源，在对象析构时自动释放资源，从而确保资源不会泄漏。

RAII核心思路主要聚焦于资源获取及资源释放,将资源获取与对象初始化进行绑定(如 `new`分配内存,`fopen`打开文件,`lock`加锁等),资源释放与对象析构绑定(如 `delete`释放内存,`fclose`关闭文件,`unlock`解锁等).

由于C++中,对象的声明周期由其作用域决定,离开作用域时自动调用析构函数.**因此,RAII对象离开作用域时,析构函数会自动执行,资源被可靠释放,无需手动操作.**

RAII解决了传统手动管理资源的缺陷,解决开发者遗忘释放的错误.在异常处理时,由于 `throw`语句可能会跳过后续的资源释放代码,RAII可以自动释放,保证了异常安全.

---

智能指针满足了RAII的设计思路,除了构造函数和析构函数,为了满足指针对于资源访问的作用,还需要运算符重载 `operator*(),operator->(),operator[]`等.下面是一个简单的智能指针实现.

```cpp
template<class T>
class SmartPtr {
public:
    // RAII
    SmartPtr(T* p) : _ptr(p)
    {
  	cout << "new" << endl;
    }
    ~SmartPtr() 
    {
        cout << "delete" << endl;
        delete _ptr;
    }

    // 运算符重载, 提供指针操作接口
    T& operator*() const { return *_ptr; }
    T* operator->() const { return _ptr; }
private:
    T* _ptr;
};
```

下面验证智能指针在 `throw`异常后,能自动释放资源.

```cpp
void test_smart_ptr()
{
    cout << "\n----- 测试智能指针 -----\n";
    SmartPtr<int> a = new int(0);

    // 模拟异常
    throw std::runtime_error("模拟异常");
}

int main() {
    try {
        test_smart_ptr();
    }
    catch (const std::runtime_error& e) {
        cout << e.what() << endl;
    }
    return 0;
}


```

在 `test_smart_ptr`中,首先用智能指针指向新在堆中申请的空间,随后模拟异常,并没有显式写 `delete`,智能指针也不需要写.在 `main`中,调用 `test_smart_ptr`,捕捉异常.程序运行如下:

```bash
----- 测试智能指针 -----
new
delete
模拟异常
```

可以看到,虽然抛出异常,智能指针的析构函数仍会在栈展开时自动调用,将资源进行释放.

# 智能指针的使用

>  C++ 智能指针（Smart Pointers）是封装了原始指针的模板类，用于核心作用是 **自动管理动态内存** ，避免内存泄漏（忘记手动释放）和悬垂指针（访问已释放内存）等问题。C++11 及后续标准提供了三种常用智能指针：`std::unique_ptr`、`std::shared_ptr` 和 `std::weak_ptr`，均定义在 `<memory>` 头文件中。

`auto_ptr`是C++98时设计出来的智能指针，他的特点是拷贝时把被拷贝对象的资源的管理权转移给拷贝对象，这是一个非常糟糕的设计，因为他会到被拷贝对象悬空，访问报错的问题，C++11设计出新的智能指针后，强烈建议不要使用auto_ptr。其他C++11出来之前很多公司也是明令禁止使用这个智能指针的。

## unique_ptr:独占所有权的智能指针

`unique_ptr` 是**独占式**智能指针，同一时间内只能有一个 `unique_ptr` 指向同一对象，所有权不可共享。当 `unique_ptr` 销毁（如离开作用域）时，会自动释放所指向的内存。不需要指针拷贝的情况下推荐使用.

下面的代码可以看到,`unique_ptr`指向一个对象,其性能接近原始指针,无额外引用计数开销.

```cpp
int main() {
    // 创建 unique_ptr，指向 int 类型的动态内存（值为 10）
    unique_ptr<int> ptr1(new int(10));
    cout << *ptr1 << endl;   // 输出:10

    // 所有权转移（ptr1 不再拥有内存，变为空）
    unique_ptr<int> ptr2(move(ptr1));
    if (ptr1 == nullptr) {
        cout << "ptr1为空" << endl;
    }
    return 0;
}
```

**数组特化**

`unique_ptr` 对数组有专门支持，会自动调用 `delete[]` 释放内存：

```cpp
    unique_ptr<int[]> arr(new int[3] {1, 2, 3});    // 指向数组
    cout << arr[0] << arr[1] << arr[2] << endl;     // 输出123
```

## shared_ptr:共享所有权的智能指针

`shared_ptr` 是**共享式**智能指针，允许多个 `shared_ptr` 指向同一对象，通过 **引用计数** （Reference Count）跟踪对象的所有者数量。当最后一个 `shared_ptr` 销毁时，对象才会被释放。

`shared_ptr`支持复制,每次复制会使引用计数加1;销毁时引用计数减1,计数为0时释放内存.

```cpp
int main()
{
    // 创建 shared_ptr, 引用计数初始为1
    shared_ptr<int> ptr1(new int(20));
    cout << "引用计数: " << ptr1.use_count() << endl;

    // 复制 ptr1, 引用计数变为2
    shared_ptr<int> ptr2 = ptr1;
    cout << "引用计数: " << ptr1.use_count() << endl;

    // 重置ptr1(不再指向对象),引用计数变为1
    ptr1.reset();
    cout << "引用计数: " << ptr2.use_count() << endl;

    return 0;
}
```
